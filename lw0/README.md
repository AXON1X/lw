# Лабороторная работа номер 0
:file_folder:
+ Функция примитивного калькулятора
+ Функция примитивного сумматора времён
+ Выше перечисленные функции с использование аргументов

:warning:__WARNING__:warning:  
Все комментраии в отрывках кода присутствуют только ради пояснительной цели  
Каждый комментарий в исходном коде файла был отформатирован, как лишний мусор. Читайте документацию и радуйтесь, что она вообще есть.

## Функция Calculate
:memo:Техническое задание:  
Создать функцию калькулятора, которая принимает строку, обрабатывает ее и возвращает значение в виде строки.  

:warning:Примечание:  
Количество слогаемых не должно превышать отметку в количестве 5 штук.  
Доступные операции это:  
+ Сложение  :heavy_plus_sign:
+ Вчычитание :heavy_minus_sign:

В исходной строке не должны присутствовать лишние символы  
Первый элемент строки не должен быть операцией, т.е. первое слогаемое не должно быть отрицательным и/или иметь положительный знак суммы

### Описание хода выполнение работы
+ Проверка строки на лишние символы и количество слогаемых
+ Обработка и переопределение слогаемых/операций в массивы для дальнейшей работы с данными
+ Переопределение оигинальной строки в выводимое значение

### Проверка строки на ввод
Для начала строка присваивается из аргумента ___$argv[1]___
```php
<?php
$input = $argv[1];
    ...
```

После чего заносится в функцию как аргумент
```php
function calculate($input): string
{
    ...
```
В функции непосредственно создаются массивы, счетчики и строка для проверки на ввод, а так же переопрееляется строка чтобы она воспринималась как массив из символов, а не просто строка
```php
    $numbers = []; //массив слогаемых
    $numberCounter = 0; // счетчик для слогаемых
    $operations = []; // массив операций
    $operationsCounter = 0; // счетчик для операций
    $strCheckNum = "  +-0123456789"; // строка для проверка на ввод с учетом пробела
    $inputTwink = str_split($input); // переопределение (создание) массива символов из оригинальной строки  -> оттуда и приставка Twink
```
После создания переменных идет проверка на первый символ. В случае обнаружения ошибки возврат сообщения о неккоректном вводе
```php
if ($inputTwink[0] === '+' or $inputTwink[0] === '-' or !strpos($strCheckNum, $inputTwink[0])) {
        $input = "unexpected error";
        return $input;
    }
```
### Обработка строки
Если условие оказалось __false__, то запускается цикл ___Foreach___
в котором проверяется  
+ наличие посторонних символов
+ является символ операцией или нет для записи слогаемых
+ необходимость перехода на следующую ячейку памяти массива слогаемых/операций

Для начала сам цикл и проверка на символы
```php
foreach ($inputTwink as $symbol) {
    // $strCheckNum = "  +-0123456789";
        if (!strpos($strCheckNum, $symbol)) {
            $input = "Error"; //запись об ошибке
            return $input; // возврат строки
        }
    ...
```
Далее продемонстрирован код записи слогаемых в массив ___$numbers___  
Он так же находится в цикле. Не теряйте цепочку мыслей!
```php
...
 if ($symbol !== '+' and $symbol !== '-') {
            $numbers[$numberCounter] .= $symbol;
        }
```
Если символом оказалась операция, то операция заноситя в массив операций, а так же меняется счётчик самой операции и счётчик слогаемых. Добавлена проверка на количесто операций и количество слогаемых
```php

else {
            $numbers[$numberCounter] = intval($numbers[$numberCounter]);
            //конвертация слогаемого из строки в целочисленное значение
            $operations[$operationsCounter] .= $symbol;
            //запись операции
            $numberCounter++;
            //изменение счётчика слогаемых
            $operationsCounter++;
            //изменение счётчика операций
            if ($numberCounter >= 6 or $operationsCounter >= 5) {
                $input = "Numbers of terms exceeded or number of operations exceeded";
                return $input;
            } // проверка на количество операций и слогаемых согласно техническому заданию
        }
    }
```
После всей проделанной работы остаётся дело за малым, не расслабляйтесь!  
Кружка чая это всегда хорошо, поэтому я сделаю перерыв, ведь для вас я пропаду буквально таки на одну строчку  
CTRL+S+S+S+S:rage1:  
Как хорошо, что это тестовая докуентация, где нет строгого ТЗ и позволено использовать стикеры)  
Так, о чем это я? Ах да...  

### Завершение функции Calculate
Для записи ответа я создаю переменную __$result__ в которую передам значение первого элемента массива слогаемых.  
Небольшая ремарка: : Можно было её задать нулём, но почему-то компилятор не воспринял эту затею нормальной... Да и цикл на один шаг будет меньше - главное что оно работает  
```php
 $result = $numbers[0];
```
Последний цикл в функции _Calculate()_ - это проверки на операции и сами операции между слогемыми  
```php
for ($i = 1, $j = 0; $i < 5; $i++) {
        if ($operations[$j] === '+') {
            $result += $numbers[$i];
        } else {
            $result -= $numbers[$i];
        }
        $j++; //переключение счётчика на следующую операцию
    }
```
На этом функция _Calculate()_ заканчивается...  
Добавим ответ к основной строке и вернём ее как выходное значение
```php
$input .= " = " . $result;
    return $input;
}
```
Функция завершена!

создадим переменную ___$output___ для вывода значения
```php
$output = calculate($input); // присваивание обработанной строчке переменной для вывода, т.к. функция должна возвращать значение
echo $output; // вывод
```
## Функция SunTime

:memo:Техническое задание:  
Создать функцию сумматора двух времен, которая принимает две строки, обрабатывает их и возвращает значение в виде строки.  

:warning:Примечание:  
В исходной строке не должны присутствовать лишние символы  
Время должно быть в 24 формате, т.е

| значение     | час | минута | секунда |
| ------------ | --- | ------ | ------- |
| Максимальное | 23  | 59     | 59      |
| Минимальное  | 0   | 0      | 0       |

Описаиние хода выполнения работы
+ Обработка вводимых строк на ошибки ввода
+ Запись значений
+ Сумма времен и вывод значения  
  
## Проверка строки на ввод
Так же как и в функции ___Calculate___ я создаю строки и ввожу их как аргуммент функции
```php
<?php

$firstTime = $argv[1];
$SecondTime = $argv[2];

function sunTime($firstTime, $SecondTime): string
{
    ...
```

Создаю строку для проверки на ввод  и переменную для вывода. Так же переопределя строки для того, чтобы они воспринимались, как массив символов. Два массива для двух времен и для них два счётчика
```php
    $result = ""; // переменная вывода
    $checkStr = "  :0123456789"; // строка для проверки
    $firstTimeTwink = str_split($firstTime); // переопределение массива
    $SecondTimeTwink = str_split($SecondTime); // 2е переопределение массива
    $firstTimeArr = []; // массив для времени
    $firstTimeCounter = 0; // счётчик для первого массива
    $secondTimeArr = []; // массив для второго времени
    $secondTimeCounter = 0; // счётчик для второго времени
```
Если хоть один аргумент окажется пустым (_NULL_) или количество символов окажется больше 8, то происходит выброс ошибки

```php
if($firstTime === NULL or $SecondTime === NULL or (strlen($firstTime) > 8) or (strlen($SecondTime) > 8))
    {
        $result = "Unexpected Error!";
        return $result;
    }
```

##  Запись элементов времени
Условие _False_? Тогда идём дальше...  
  
  Начало цикла обработки. Я разберу первый цикл обработки времени, а второй оставлю как код, т.к. они идентичны

  ```php
  foreach($firstTimeTwink as $symbol)
    {
        if(!strpos($checkStr, $symbol))
        {
            $result = "It looks like there are extra characters int the argument...";
            return $result;
        }
        if($symbol !== ':')
        {
            $firstTimeArr[$firstTimeCounter] .= $symbol;
        }
        else
        {
            $firstTimeArr[$firstTimeCounter] = intval($firstTimeArr[$firstTimeCounter]);
            $firstTimeCounter++; 
        }
    }
  ```
  Здесь есть аналогия с Калькулятором, т.е. пока символ не равен определенному значению в первый массив записывается значение под нулевым итератором
  ```php
if($symbol !== ':')
        {
            $firstTimeArr[$firstTimeCounter] .= $symbol;
        }
  ```
  В противном случае итератор меняет своё значение на следующий элемент, а значение массива сразу конвертируется в целочисленное
  ```php
$firstTimeArr[$firstTimeCounter] = intval($firstTimeArr[$firstTimeCounter]);
            $firstTimeCounter++; 
  ```
  Так же и по аналогии со вторым циклом

  ```php
foreach($SecondTimeTwink as $symbol)
    {
        if(!strpos($checkStr, $symbol))
        {
            $result = "It looks like there are extra characters int the argument...";
            return $result;
        }
        if($symbol !== ':')
        {
            $secondTimeArr[$secondTimeCounter] .= $symbol;
        }
        else
        {
            $secondTimeArr[$secondTimeCounter] = intval($secondTimeArr[$secondTimeCounter]);
            $secondTimeCounter++;
        }
    }
  ```

  Момент, который стоило продумать чутка раньше, но я решил позаботится о пользователе, ведь в теории он всегда имеет не самые прямые руки и может ввести бред. Как оказывается еще и на практике, криворуким может оказатся не только пользователь, но и сам разработчик... Благо у меня есть смекалка на такой случай жизни  

  Если размер массивов нас не удволетворяет, то фантомная рука разраба поможет устранить это недоразумение во избежание лишних ошибок. Я просто задам недостающим значениям по стандартному значению ー 0  
  Таким образом ваше кривое значение превратится в более менее читабельную и воспринимаемую информацию!  
  | Было     | обработка                    | Стало      |
  | -------- | ---------------------------- | ---------- |
  | 01:1:    | :memo:                       | 01:01:00   |
  | ::001    | :memo:                       | 00:00:01   |
  | 123::456 | :muscle::alien::point_right: | 123:00:456 |

  Так как это не конечное значение его можно оставить в таком безобразном виде  

  По коду все очень просто  

  ```php
if(sizeof($secondTimeArr) === 1)
    {
        $secondTimeArr[1] = intval(0);
        $secondTimeArr[2] = intval(0);
    }
    if(sizeof($secondTimeArr) === 2)
    {
        $secondTimeArr[2] = intval(0);
    }

    if(sizeof($firstTimeArr) === 1)
    {
        $firstTimeArr[1] = intval(0);
        $firstTimeArr[2] = intval(0);
    }
    if(sizeof($firstTimeArr) === 2)
    {
        $firstTimeArr[2] = intval(0);
    }
  ```

  Отлично! создадим переменные часа, минуты и секунды и сразу зададим им нужные значения

  ```php
    $second = $firstTimeArr[2] + $secondTimeArr[2];
    $minute = $firstTimeArr[1] + $secondTimeArr[1];
    $hour = $firstTimeArr[0] + $secondTimeArr[0];
  ```
  И так остаётся привести переменные в порядок. Три простых цикла с простыми условиями. Начать следует с малого, т.е. секунд, ведь не сделав это придется писать доп. условия, а разрабы не дауны :godmode:

  ```php
while($second > 59)
    {
        $second -= 60;
        $minute++;
    }
    while($minute > 59)
    {
        $minute -= 60;
        $hour++;
    }
    while($hour > 23)
    {
        $hour -= 24;
    }
  ```

  Наконец-то момент истинны! То для чего создавалась переменная ___$result___ и сама функция ___SunTime()___

  ```php
    $result =  $hour . ":" . $minute . ":" . $second . "\n";
    return $result;
  ```

  ## Вывод

  Это конец... но... какой ценой? ценой всего? сквозь простенькие ТЗ и одну душную документацию... выводим значение и завершаем программу  

  ```php
    $output = sunTime($firstTime, $SecondTime);
    echo $output;
  ```

  Документацию составил: Валиев Евгений :feelsgood:  
  Программы написал: AXON1X он же и AXONIX  :godmode:  
  (Возможно) дочитал до конца: ТЫ

  Отдельная благодарность Тебе, твоим родственникам, собаке, кошке и супругу, что ты решился дочитать эту душную документацию.

  Меня ждёт еще много таких душных документаций, поэтому я с вами не прощаюсь! А на этом у меня все...